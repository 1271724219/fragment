/* 
给你一个长度为 n 的整数数组 nums 。请你构建一个长度为 2n 的答案数组 ans ，数组下标 从 0 开始计数 ，对于所有 0 <= i < n 的 i ，满足下述所有要求：

ans[i] == nums[i]
ans[i + n] == nums[i]
具体而言，ans 由两个 nums 数组 串联 形成。

返回数组 ans 。

*/
/**
 * * 思路
 * 题意可知，只想吧这个数组不管多少重复一遍，那么可以直接操作这个数组。
 * 1.记录这个数组的长度为n
 * 2. 遍历数组终止条件为n，并将原数组的n+1项添加为索引为i的值
 * 3.返回这数组
 * 接下来我们使用代码实现
 */
var getConcatenation = function (nums) {
  //  1.
  let n = nums.length;
  // 这里注意循环之前必须新生成个变量，千万不要偷懒，因为我们直接操作原数组，原数组的长度会变化，会陷入无限死循环中
  for (let i = 0; i < n; i++) {
    //2
    nums[n + i] = nums[i];
  }
  //   3
  return nums;
};
/**
 * *复杂度分析
 * 时间复杂度:O(n),n为数组的长度
 * 空间复杂度:O(1) 这里并没有使用新的数据结构
 */
